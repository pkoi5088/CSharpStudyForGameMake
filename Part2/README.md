# 자료구조 및 알고리즘
본 Part의 내용은 MMORPG나 RPG에서 꼭 필요한 길찾기에 대한 내용이다. 온라인 게임에서 캐릭터나 몬스터의 이동에서 길찾기 알고리즘을 한번쯤은 직접 구현해볼 것이다.  
우수법, BFS, 다익스트라, A*에 대해서 알아보고 간단한 미로프로잭트를 구현해볼 예정이다.
***
## 내용
* [Big-O 표기법](#BigO-표기법)
* [선형 자료구조](#선형-자료구조)
    + [배열](#배열)
    + [동적배열](#동적배열)
    + [연결리스트](#연결리스트)
* [미로 만들기](#미로-만들기)
    + [Binary Tree 미로 생성 알고리즘](#binary-tree-미로-생성-알고리즘)
    + [SideWinder 미로 생성 알고리즘](#sidewinder-tree-미로-생성-알고리즘)
    + 이동 및 우수법
* 그래프
* 트리
* A*알고리즘
## Big-O 표기법
두 알고리즘 A,B을 비교하기 위해서?
```
    1. A가 B보다 조금 빠르다 => 모호함
    2. 실행속도 비교 => 실행 환경에 따라 다름
    3. 입력값의 범위와 개수에 따라서?
```
**BIG-O를 사용하자!**
1. 수행되는 연산의 개수를 '대략적으로' 판단한다.
2. 가장 영향력이 큰 항만 남기자
```
    O(N^2 + N + 4) = O(N^2)
```
3. BIG-O 복잡도 성능 순서
```
    O(1), O(logN), O(N), O(NlogN), O(N^2), O(2^N), O(N!)
```
***
## 선형 자료구조
자료를 순차적으로 나열한 자료구조
### 배열
```
    일정한 크기의 자료들이 순서대로 나열된 자료구조
    단점: 개수의 추가가 어렵다.
```
### 동적배열
```
    배열의 단점을 개선한 구조로 유동적으로 개수를 조절할 수 있는 자료구조(List)
    단점: 개수를 조절하는데에 비용이 과다하게 발생한다면 비효율적
```
### 연결리스트
```
    자료들을 임의의 곳에 저장하되 순서에 따라 포인터를 이용해 자료들을 서로 연결해 놓은 자료구조
    장점: 중간에 삽입, 삭제가 가능하다
    단점: N번째 자료를 조회하는데 시간이 걸린다
```
***
## 미로 만들기
길찾기 알고리즘을 단일 샘플에 따라 찾는것이 아닌 자동으로 생성된 랜덤 미로에서 잘 작동이 되는지 확인하기 위한 단계
>맵의 전체 크기는 홀수이어야 한다.
### Binary Tree 미로 생성 알고리즘
*Board.cs의 GenerateByBinaryTree()참조*
#### 원리
```
    1. x,y좌표중에서 하나라도 짝수라면 해당 점을 벽으로 만든다.
    2. 각각의 빈공간에 대해서 오른쪽 벽을 없앨지, 아래 벽을 없앨지 결정한다.
    3. 외벽이 뚫렸을 경우, 다시 벽으로 만든다.
    4. 도착점까지 도달을 못하는 미로일수 있음으로, 외벽을 제외한 가장 아래 줄과 가장 오른쪽 줄을 전체 빈공간으로 만든다.
```
#### 코드 설명
1. x가 짝수거나 y가 짝수면 해당 점을 벽으로 만든다.
```c#
            for(int y = 0; y < _size; y++)
            {
                for(int x = 0; x < _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        _tile[y, x] = TileType.Wall;
                    else
                        _tile[y, x] = TileType.Empty;
                }
            }
```
2. 빈 공간인 점들에 대해서 오른쪽, 아래벽중 뚫을 벽을 정하고 위의 3,4번 과정을 거쳐준다.
```c#
            Random rand = new Random();
            for (int y = 0; y < _size; y++)
            {
                for (int x = 0; x < _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        continue;
                    //도착점일 경우 뚫지 않는다.
                    if (y == size - 2 && x == size - 2)
                        continue;
                    
                    //가장 아래 점, 가장 오른쪽 점일 경우 빈공간으로 만든다.
                    if (y == size - 2)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                        continue;
                    }
                    if (x == size - 2)
                    {
                        _tile[y+1, x] = TileType.Empty;
                        continue;
                    }

                    //오른쪽과 아래쪽중 선택해 벽을 빈공간으로 만든다.
                    if (rand.Next(0, 2) == 0)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                    }
                    else
                    {
                        _tile[y + 1, x] = TileType.Empty;
                    }
                }
            }
```
#### 단점
>미로의 모양이 일정한 규칙이 존재한다.
ex. 가장 아래줄이나 가장 오른쪽 줄은 항상 빈칸이다.
### SideWinder Tree 미로 생성 알고리즘
*Board.cs의 GenerateBySideWinder()참조*
#### 원리
```
    1. x,y좌표중에서 하나라도 짝수라면 해당 점을 벽으로 만든다.
    2. 각각의 빈공간에 대해서 오른쪽 벽을 없앨지, 아래 벽을 없앨지 결정한다.
    3. 아래벽을 없앨시, 해당 점의 아래를 뚫는 것이 아니라 최근에 오른쪽으로 진행된 점들을 포함한 그룹들 중에서 아래벽을 뚫는다.
    4. 외벽이 뚫렸을 경우, 다시 벽으로 만든다.
    5. 도착점까지 도달을 못하는 미로일수 있음으로, 외벽을 제외한 가장 아래 줄과 가장 오른쪽 줄을 전체 빈공간으로 만든다.
```
#### 코드 설명
1,2,4,5번은 BinaryTree알고리즘과 동일하다.
3. 아래벽을 없앨시, 해당 점의 아래를 뚫는 것이 아니라 최근에 오른쪽으로 진행된 점들을 포함한 그룹들 중에서 아래벽을 뚫는다.
```c#
            Random rand = new Random();
            for (int y = 0; y < _size; y++)
            {
                int count = 0;
                for (int x = 0; x < _size; x++)
                {
                    if (x % 2 == 0 || y % 2 == 0)
                        continue;
                    if (y == _size - 2 && x == _size - 2)
                        continue;

                    if (y == _size - 2)
                    {
                        _tile[y, x + 1] = TileType.Empty;
                        continue;
                    }
                    if (x == _size - 2)
                    {
                        _tile[y + 1, x] = TileType.Empty;
                        continue;
                    }

                    if (rand.Next(0, 2) == 0)
                    {
                        //오른쪽으로 뚫을 시 카운트해준다.
                        _tile[y, x + 1] = TileType.Empty;
                        count++;
                    }
                    else
                    {
                        //아래로 뚫을 시 최근에 오른쪽으로 뚫은 점들을 포함해 하나를 아래로 뚫는다.
                        int randomIndex = rand.Next(0, count);
                        _tile[y + 1, x - randomIndex * 2] = TileType.Empty;
                    }
                }
```
#### 단점
>BinaryTree 알고리즘과 마찬가지로 미로의 모양에 일정한 규칙이 존재한다.
## 이동 및 우수법
### 플레이어 이동
길찾기 알고리즘을 수행하는 개체(플레이어)를 Player.cs에 생성한 뒤 플레이어의 위치를 표시하기 위한 작업을 수행한다. 또한 플레이어의 위치를 수정하기위한 Update()도 작성해준다.
### 우수법
플레이어가 현재상태에서 어떻게 이동할지에 대한 판단을 내리는 방법을 Update()에 구현해야한다. 현재 단계에서는 우수법을 Update()에 구현할 것이다.
>우수법이란?
한쪽 손을 벽에 붙이고 이동하는 방법으로 미로는 결국 면으로 이루어져 있기 때문에 언젠가는 미로에서 탈출할 수 있다는 접근법

